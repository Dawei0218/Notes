# 面向对象

### 类

```cpp
// 如果存在类内的初始化，用它来初始化，否则默认初始化
// 如果类中包含其它类类型成员，且这个类没有默认构造函数，编译器将无法初始化

// 常量对象不能调用普通成员函数
class S
{
    // const成员函数也可以修改
	mutable int a = 1;
    int b = 0;
    
public:
    // 定义在类内的成员函数默认是内联（inline）的
    // 也可以在类的外部定义处声明为inline、内部定义为inline而外部不用定义
    // 最好只在类的外部定义inline
    int getA() { return a; }
    int getB();
    
    // const成员函数
    int demo() const;
}

// 在类内声明，类外定义
int S::getB()
{
    return b;
}

int main()
{
    const S s1;
    s1.getB(); // 错误，常量对象不能调用普通成员函数
}
```

------

### 友元

```cpp
class S
{
    friend void add(S &s1, S &s2)
    int a, int b;
}

// 可以操作私有对象
void add(S &s1, S &s2)
{
    s1.a += s2.a;
    s1.b += s2.b;
}
```

-------

### 构造函数

```cpp
// 类在初始化变量、以值的方式传递、返回一个对象会发生拷贝	
class S {
public:
    // 显式生成默认构造函数
    S() = default;
	
    // 构造函数初始值列表，初始化的顺序按照成员对象的顺序进行的
    // 常量对象，引用只能用初始值列表方式
	S(int v) : a(v) {} 
  	
    // 编译器默认合成拷贝、赋值和销毁的操作
    
    
 	// 阻止拷贝，虽然定义了但是不能使用
  	S(const S &s1) {} = delete; 
}

// 静态成员必须在类外部初始化
int s::a = 10;
```

------

### 析构函数

```cpp
// 变量离开作用域时被销毁
// 当一个对象被销毁时，其成员被销毁
// 容器、数组被销毁，其元素被销毁
// delete
// 临时对象，创建完他的完整表达式子
class S {
public:
  ~S();
};
```

------

### 继承

```cpp
// 构造函数会先执行父类然后执行子类的
// 析构函数会先执行子类然后执行父类的
// 成员变量是类变量，会先执行成员变量的构造，然后执行自己的构造。析构会先执行自己的析构，最后执行成员变量的析构
// 如果成员变量的类指针，在new的时候执行构造，delete析构
class Parent {
    int b; // 默认是private 会被子类继承但是会被隐藏
public:
  	int a;
}

class s : public Parent {
  
}

class s : protected Parent {
  // a 会变成保护属性
}

class s : private Parent {
  // a 会变成私有属性
}

// 菱形继承
class Base {
  int a;
  int b;
}

class Parent1 : virtual public Base {}
class Parent2 : virtual public Base {}

// 虚继承
// 当多继承时有多份相同数据，使用虚继承就变成只有一个了
// 实际上是吧变量放在vbtable里，两个父类的共享同一对象。如果不加virtual就是没份数据一个
class s : public Parent1, public Parent2 {}
```

------

### 虚函数（多态）

```cpp
class Parent {
  public:
  	virtual void func() 
    {
      cout << "parent cout" << endl;
    }
}

class Child : public Parent {
  public:
  	virtual void func()
    {
      cout << "child cout" << endl;
    }
}

void doFuncz(Parent &p) {
  p.func(); // 如果不是虚函数就会调用父类的
}
```

------

### 纯虚函数（抽象类）

```cpp
// 抽象类无法实例化
// 子类必须重写纯虚函数
class Base {
  public:
  virtual void func() = 0;
}

class S {
  public:
  virtual void func()
  {
    cout << 1 << endl;
  }
}
```

------

### 运算符重载

```cpp
class s {
  public:
  int a;
  s &operator<<(cout, s &s1) {
    cout << a;
    
    return *this;
  }
}
```

-------

### 线程安全的class的定义

```
1. 多个线程同时访问时，其表现出正确的行为
2. 无论操作系统如何调度这些线程，无论这些线程的执行顺序、如何交织（interleaving）
3, 调用端代码无须额外的同步或其他协调动作
```

------

### 对象构造的线程安全

```
不要在构造函数里泄露this指针
1. 不要在构造函数中注册任何回调； 
2. 也不要在构造函数中把this传给跨线程的对象
3. 即便在构造函数的最后一行也不行

如果要传递单独写个方法，进行二段式构造
```

