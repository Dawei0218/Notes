# 面向对象

### struct与class

```cpp
// struct与class都能实现面向对象
// 默认初始化和内存位置有关，不确定性
struct s {
  int a;
  int b;
  int func1();
}

class s {
  public:
  	int a;
  	int b;
  	int func1();
  private:
  	int c;
}

int s::func1()
{
  return 0;
}
```

------

### 构造函数

```cpp
// 只有当类没有申明任何构造函数时，才会生成默认构造函数。= default显式指定生成默认构造函数
struct S {
    int a;
  	int b = 1;
    S() = default;
    S(int v) : a(v) {} // 构造函数初始值列表，初始化的顺序按照成员对象的顺序进行的
  
  	// 拷贝构造函数，即使我们定义其他构造函数，编译器也会默认生产拷贝构造函数
  	// 如果自己写了拷贝构造为空，如果调用拷贝构造就是空操作
  	S(const S &s1) {}
    
    S(const S &s1) {} = delete; // 阻止拷贝，虽然定义了但是不能使用
};

class S {
public:
  int a;
  S(int a) : a(a) {} // 初始化
  S(int num1, int num2);
}

S::S(int num1, int num2) 
{
  // 赋值，如果是const变量只能使用列表初始化
  a = num1;
}
```

------

### 析构函数

```cpp
class S {
public:
  ~S();
};
```

------

### 继承

```cpp
// 构造函数会先执行父类然后执行子类的
// 析构函数会先执行子类然后执行父类的
// 成员变量是类变量，会先执行成员变量的构造，然后执行自己的构造。析构会先执行自己的析构，最后执行成员变量的析构
// 如果成员变量的类指针，在new的时候执行构造，delete析构
class Parent {
    int b; // 默认是private 会被子类继承但是会被隐藏
public:
  	int a;
}

class s : public Parent {
  
}

class s : protected Parent {
  // a 会变成保护属性
}

class s : private Parent {
  // a 会变成私有属性
}

// 菱形继承
class Base {
  int a;
  int b;
}

class Parent1 : virtual public Base {}
class Parent2 : virtual public Base {}

// 虚继承
// 当多继承时有多份相同数据，使用虚继承就变成只有一个了
// 实际上是吧变量放在vbtable里，两个父类的共享同一对象。如果不加virtual就是没份数据一个
class s : public Parent1, public Parent2 {}
```

------

### 友元

```cpp
// 允许其它类或者函数访问它的非公有成员
// 在函数前加friend

class t {
    
    friend void print_age(t t1);
  	friend class s;
  	friend void s::func();
    
    private:
    	string name;
    	int age;
}

// 一个外部函数
// 默认不能访问，加上friend就可以了
void print_age(t t1)
{
    cout << t1.age << endl;
}
```

------

### this

```cpp
class s {
  public:
  int a;
  int b;
  // 可以用this，也可以直接return a
  int getA() 
  { 
      return this->a; 
  }
  
  // 把this改为const s * const this
  int getB() const 
  {
      return this->b;
  }
}

// 实际上调用getA() = getA(&s1)
s s1;
s1.getA();
```

------

### mutable

```cpp
class s {
  public:
  	void incr_a() const { ++a; } // 在const对象中也可以修改a对象
  private:
  	mutable int a;
}
```

------

### 类的静态成员

```cpp
// 类需要一些成员与类本身直接相关，而不是与类的各个对象保持关联
// 比如一个银行账户类需要一个数据成员表示当前利率，需要和类关联，但是并非与所有对象关联
class s {
  public:
  static int a;
}

// 必须在类外部初始化
int s::a = 10;

int main()
{
	cout << s::a << endl;
}
```

------

### 虚函数（多态）

```cpp
class Parent {
  public:
  	virtual void func() 
    {
      cout << "parent cout" << endl;
    }
}

class Child : public Parent {
  public:
  	virtual void func()
    {
      cout << "child cout" << endl;
    }
}

void doFuncz(Parent &p) {
  p.func(); // 如果不是虚函数就会调用父类的
}
```

------

### 纯虚函数（抽象类）

```cpp
// 抽象类无法实例化
// 子类必须重写纯虚函数
class Base {
  public:
  virtual void func() = 0;
}

class S {
  public:
  virtual void func()
  {
    cout << 1 << endl;
  }
}
```

------

### 运算符重载

```cpp
class s {
  public:
  int a;
  s &operator<<(cout, s &s1) {
    cout << a;
    
    return *this;
  }
}
```

------

### 对象拷贝

```c++
// 初始化变量以及以值的方式传递或返回一个对象
class A 
{
public:
  ~A()
  {
    std::cout << "This is the destruction of class A" << std::endl;
  }
}

void demo(A a) {}

int main()
{
  A a;
  demo(a);
}
```

