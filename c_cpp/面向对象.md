# 面向对象

### 构造函数

```cpp
// 如果存在类内的初始化，用它来初始化，否则默认初始化
// 如果类中包含其它类类型成员，且这个类没有默认构造函数，编译器讲无法初始化
// 只有类不包含任何构造函数的情况下，才会生成的构造函数。= default显式指定生成默认构造函数

// 类在初始化变量、值的方式传递、返回一个对象会发生拷贝
class S {
// 友元，可以访问私有属性
friend void print_age(S s1);
friend class S1;
friend void S1::func();
  
// 默认是private属性
public:
  // const对象中也可修改此成员
  mutable int a;
  static int b;
  
	S() = default;
  S(int v) : a(v) {} // 构造函数初始值列表，初始化的顺序按照成员对象的顺序进行的
  
  // 拷贝构造函数，即使我们定义其他构造函数，编译器也会默认生产拷贝构造函数
  S(const S &s1) {}
    
  S(const S &s1) {} = delete; // 阻止拷贝，虽然定义了但是不能使用
  S(int num1, int num2);
  
  // 定义在类内部的成员函数默认是inline的
  int getA() { return this->a }
}

S::S(int num1, int num2) 
{
  // 赋值，如果是const变量只能使用列表初始化
  a = num1;
}

// 必须在类外部初始化
int s::a = 10;

int main()
{
  cout << s::a << endl;
}
```

------

### 析构函数

```cpp
// 变量离开作用域时被销毁
// 当一个对象被销毁时，其成员被销毁
// 容器、数组被销毁，其元素被销毁
// delete
// 临时对象，创建完他的完整表达式子
class S {
public:
  ~S();
};
```

------

### 继承

```cpp
// 构造函数会先执行父类然后执行子类的
// 析构函数会先执行子类然后执行父类的
// 成员变量是类变量，会先执行成员变量的构造，然后执行自己的构造。析构会先执行自己的析构，最后执行成员变量的析构
// 如果成员变量的类指针，在new的时候执行构造，delete析构
class Parent {
    int b; // 默认是private 会被子类继承但是会被隐藏
public:
  	int a;
}

class s : public Parent {
  
}

class s : protected Parent {
  // a 会变成保护属性
}

class s : private Parent {
  // a 会变成私有属性
}

// 菱形继承
class Base {
  int a;
  int b;
}

class Parent1 : virtual public Base {}
class Parent2 : virtual public Base {}

// 虚继承
// 当多继承时有多份相同数据，使用虚继承就变成只有一个了
// 实际上是吧变量放在vbtable里，两个父类的共享同一对象。如果不加virtual就是没份数据一个
class s : public Parent1, public Parent2 {}
```

------

### 虚函数（多态）

```cpp
class Parent {
  public:
  	virtual void func() 
    {
      cout << "parent cout" << endl;
    }
}

class Child : public Parent {
  public:
  	virtual void func()
    {
      cout << "child cout" << endl;
    }
}

void doFuncz(Parent &p) {
  p.func(); // 如果不是虚函数就会调用父类的
}
```

------

### 纯虚函数（抽象类）

```cpp
// 抽象类无法实例化
// 子类必须重写纯虚函数
class Base {
  public:
  virtual void func() = 0;
}

class S {
  public:
  virtual void func()
  {
    cout << 1 << endl;
  }
}
```

------

### 运算符重载

```cpp
class s {
  public:
  int a;
  s &operator<<(cout, s &s1) {
    cout << a;
    
    return *this;
  }
}
```

-------

### 线程安全的class的定义

```
1. 多个线程同时访问时，其表现出正确的行为
2. 无论操作系统如何调度这些线程，无论这些线程的执行顺序、如何交织（interleaving）
3, 调用端代码无须额外的同步或其他协调动作
```

------

### 对象构造的线程安全

```
不要在构造函数里泄露this指针
1. 不要在构造函数中注册任何回调； 
2. 也不要在构造函数中把this传给跨线程的对象
3. 即便在构造函数的最后一行也不行

如果要传递单独写个方法，进行二段式构造
```

