# 数据类型

### 基本数据类型

```c
// 未初始化的值是什么由变量类型和变量的位置决定

// C99和C11遵循C++的惯例，可以把声明放在块中的任何位置
// int可以省略，long类型在32位机器4字节，64位机器8字节
int a;
short int a;
long int a;
long long int a;

// 0前缀是8进制 0x/0X前缀是16进制 0b前缀是二进制
short a = 012;

// 可用于限定char类型和int类型，int、short、long、long long类型默认带符号的
// char类型可能unsigned或signed，取决于编译器
// c/c++ unsigned int可以缩写为unsigned
unsigned int a;

// c++
wchar_t; // 宽字符
char16_t; // Unicode字符
char32_t; // Unicode字符

// 类型长度定义的符号常量以及与机器和编译器相关的属性在<limits.h>与<float.h>中
// 2.0 * 4.0 默认是double可以在后面加上F就是float
float a = 1.00;
double a = 1.00;
long double a;

// 原则上仅需1位存储空间，0表示false 1表示true
// 可以用stdbool库，与c++语法相同
_Bool a = 1;
bool a = true; // c++

// 算术运算中既有无符号又有int值时，会转成无符号
unsigned u;int u1;
u + u1;

// c++ auto类型，编译器自动推导类型
// 因为是编译器推导，所以必须有初始值
auto item = val1 + val2;

// 初始化
// 当列表初始化用于内置类型时，初始值存在丢失风险时，编译器会报错
// 未初始化的变量含有一个不确定的值
int a = 0;
int a = {0}; // 列表初始化
int a{0}; // 列表初始化
int a(0);
```

------

### 指针和引用

```cpp
int *a, b; // a是指针而b是int类型

// 引用只是一个别名，引用必须初始化
// 引用编译器转换 const int *b = &a;
int a = 1;
int &b = a;

// int tmp = 10;
// const int *b = &tmp;
int &b = 10;

// 指针保存另一个对象的地址
int a = 1;
int *p = &a;

// 空指针，nullptr是c++语法
int *p = NULL;
int *p = nullptr;

// void类型指针可以存放任意对象的地址
void *ptr;

// 指向指针的引用
int *p;
int *&r = p;
```

------

### 字符串

```c++
// 单引号括起来的char类型值，双引号是多个char类型组成的字符串，结尾包括\0
// 编译器在每个字符串结尾处增加空字符 （\0）
// 如果没有\0就是字符数组，而有\0就构成了字符串
char s[40];

// 编译器自动增加空字符
char *s = "abcdefg";

// 字符串断行
printf("string1 \
string2\n");

// 这是ANSI引入的字符串连接，下面两个是等效的
printf("string1"
      "strint2\n");
printf("strint1"    "strint2\n");

// ANSI C开始，字符串字面量之间没有间隔，或者用空白字符分割，C会将其视为串联起来的字符串字面量
char s[50] = "123""1123"   "123";

// c++ string标准库
#include <string>

// 如果使用等号是拷贝初始化，其它式直接初始化
std::string s1; // 默认初始化，空字符串
std::string s2(s1);
std::string s2 = s1;
std::string s3 = "Hello World";
std::string s4(10, 'c'); // 初始化10个c字符

s1.empty();
s1.size(); // 返回string::size_type类型
```

------

### 类型转换

```c++
// cast-name<type>(expression);
// cast-name:
//		1. static_cast
//  	2. dynamic_cast
//		3. const_cast 可以改变底层const
//		4. reinterpret_cast

double slope = static_cast<double>(i);

// const_cast 如果底层对象是非常量可以执行写操作，否则会产生为定义后果
```



