# 可执行文件装载

### 为什么要有装载？

程序执行时指令和数据必须在内存中，全部装载并不合理。后来研究发现，程序运行时是有局部性原理，所以可以将程序最常用的部分驻留内存，而将一些不太常用的数据存放在磁盘里面，等待需要时在装入，这就是动态装入的原理。

-------

### 覆盖装入

在没有发明虚拟存储之前使用比较广泛，现在已经几乎被淘汰了。

覆盖装入的方法把挖掘内存潜力的任务交给了程序员，程序员在编写程序时必须手工将程序分割成若干块，然后编写一个小的辅助代码来管理这些模块何时应该驻留内存，何时应该被替换掉。

-------

### 页映射

页映射是虚拟存储机制的一部分，它随着虚拟存储的发明而诞生。

页映射将内存和所有磁盘中的数据和指令按照`页`为单位划分成若干个页，以后所有的装载和操作的单位就是页。

需要用到哪个页就从磁盘中加载进来，使用一些淘汰算法提高内存利用率。

如果程序使用物理地址直接进行操作，那么每次页被装入时都需要重定位。有了虚拟存储，硬件MMU都提供地址转换功能。

------

### 进程的建立

创建一个进程，然后装载相应的可执行文件并且执行。

1. 创建一个独立的虚拟地址空间，实际上只是分配一个页目录，不设置映射关系，等待缺页异常时，在进行设置
2. 读取可执行文件头，并且建立虚拟空间与可执行文件的映射关系，在缺页异常时需要知道所需要的页在可执行文件的哪个位置
3. 将cpu的指令寄存器设置成可执行文件的入口地址，启动运行

假设ELF可执行文件只有一个代码段.text，虚拟空间和可执行文件的映射关系保存在操作系统内存的一个数据结构。

Linux将进程虚拟空间中的一个段（segment）叫虚拟内存区域（VMA，Virtual Memory Area），操作系统创建进程后会在进程相对应的数据结构中设置一个.text的VMA，他在虚拟空间中的地址为0x08048000~0x08049000，它对应ELF文件中偏移为0的.text，属性是只读（映射？）。

前面的例子只有一个代码段，所以它被操作系统装载至进程地址空间之后，相应的只有一个VMA。

VMA就是描述虚拟内存和可执行文件映射关系。

------

### 页错误

以上步骤执行完以后，可执行文件的指针指令和数据都没有被装入内存中。操作系统只是通过可执行文件头部的信息建立起可执行文件和进程虚存之间的映射关系而已。如果发现缺页异常，操作系统查询第二步建立的数据结构，找到空页面所在的VMA，计算出相应的页面在可执行文件的偏移，分配物理页面。

-------

### ELF文件链接视图和执行视图

section是链接视图，而segment是执行视图。

对于相同属性和权限的段（Section）合并到一起当作一个段（segment）进行映射。

比如两个.section，.init和.text合并后，装载的时候就可以就看作一个整体一起映射，也就说映射以后在进程虚拟空间中只有一个相对应的VMA，而不是两个，这样做减少页面内部碎片，节省了内存空间。

readelf -l file.elf可以查看ELF的Segment，描述Section属性的结构叫段表，描述Segment的结构叫程序头（Program Header），它描述了ELF文件如何被操作系统映射到进程的虚拟空间。

------

### 程序头表

ELF可执行文件中专门有个数据program Header Table用来保存segment信息，用来保存Segment信息

目标文件不需要执行所以没有程序头表



