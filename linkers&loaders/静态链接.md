# 静态链接

### 案例代码

```c
// a.c
extern int shared;

int main(void)
{
    int a = 100;
    swap(&a, &shared);
}

// b.c
int shared = 1;

void swap(int *a, int *b)
{
    *a ^= *b ^= *a ^= *b;
}
```

------

### 空间与地址分配

链接过程中就是把多个输入文件加工合成一个输出文件，链接器通过相似段合并把相同得段合并在一起。

------

### 两步链接

1. 扫描所有得输入目标文件，获得它们的各个段的长度、属性和位置。并且将输入目标文件的符号表中所有的符号定义和符号引用收起起来，统一放到***全局符号表***。这一步链接器能够获得所有输入目标文件的段长度，并且将它们合并，计算出输出文件中各个段合并后的长度与位置，并建立映射关系。
2. 符号解析与重定位，使用上面收集到的所有信息，读取输入文件中段的数据、重定位信息，并且进行符号解析与重定位、调整代码中的地址等。

Linux下可执行文件默认从0x08048000开始分配，

-------

### 第一步扫描和空间分配

链接器按照段合并的方法进行段合并，这时候输入文件中的各个段在链接后的虚拟地址就已经确定了。

然后链接器计算各个符号的虚拟地址，因为各个符号在段内的相对位置是固定的，所以mian、shared、swap的地址已经确定，只需要加一个偏移地址就是正确的地址，更新完全局符号表接下来就要进行第二步。

-------

### 第二步符号解析与重定位

从重定位表中找到需要修正的地方，再从全局符号表中找到值进行修正。

------

### COMMON块

弱符号的未初始化的全局变量，应该在bss段。

由于弱机制允许同一个符号存在于多个文件中，所以可能导致一个弱符号定义在多个目标文件中，但是类型不一样该怎么处理。

- 有一个强符号，其它都是弱符号出来类型不一致
- 两个或两个以上弱符号类型不一致

现在的编译器和链接器都支持COMMON块的机制。这个机制来源于Fortran，早期的Fortran没有动态分配空间的机制，程序员必须事先声明它所需要的临时使用空间的大小，当不同的目标文件需要的COMMON块空间不一致时，以最大的那块为准。

在file1定义a全局变量为int类型，file2是double类型，最终链接后的数据文件中，a的大小以输入文件最大的那个为准，所占空间为8字节。

如果一个符号为强符号那么以强符号的大小为准。如果有弱符号大于强符号ld会报警告。

这就是为什么把未初始化的全局变量标记为COMMON类型的原因。编译器把一个单元编译成目标文件的时候，如果该编译单元包含了弱符号，弱符号最终所占空间的大小在此时是未知，因为有可能其他编译单元中所占的空间比本编译单元所占空间大。在链接的时候可以确定大小

------

### 静态链接库

程序如何使用操作系统提供的API，一般情况下编程语言都会带有语言库，这些库就是对操作系统API的包装。比如printf函数在对字符串进行一些必要的处理后，最后会调用操作系统的API。

静态库就是一组目标文件的集合，即很多目标文件经过压缩打包后形成的一个文件。比如我们在Linux中最常用的C语言静态库libc位于/usr/lib/libc.a，它属于glibc项目的一部分。

```
glibc是GNU发布的libc库
```

glibc本身由C语言开发，有成百上千个c语言源代码文件组成，编译后有相等数量的目标文件，很大程度上会造成文件传输、管理和组织的不方便，于是就使用ar压缩，对其进行编号和索引。


