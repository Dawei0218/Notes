# TIME_WAIT

### 产生原因

1. TCP 连接终止时，主机 1 先发送 FIN 报文
2. 主机 2 进入 CLOSE_WAIT 状态，并发送一个 ACK 应答
3. 主机 2 通过 read 调用获得 EOF，并将此结果通知应用程序进行主动关闭操作，发送 FIN 报文。
4. 主机 1 在接收到 FIN 报文后发送 ACK 应答，此时主机 1 进入 TIME_WAIT 状态。



TIME_WAIT只发生在主动关闭的一方，在2MSL时间彻底关闭。

***

### 2MSL

- 确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭。

  如果主机 1 的 ACK 报文没有传输成功，那么主机 2 就会重新发送 FIN 报文，而直接进入 CLOSED 状态，它就失去了当前状态的上下文，只能回复一个 RST 操作，从而导致被动关闭方出现错误

  主机 1 知道自己处于 TIME_WAIT 的状态，就可以在接收到 FIN 报文之后，重新发出一个 ACK 报文，使得主机 2 可以进入正常的 CLOSED 状态

- 让旧连接的重复分节在网络中自然消失

***

### 解决方案

```C
// 当客户端与服务端主机时间不同步时，客户端的发送的消息会被直接拒绝掉
// 只适用连接发起的一方
// 需要net.ipv4.tcp_timestamps=1
// 现代 Linux 系统引入了更安全可控的方案，可以帮助我们尽可能地复用 TIME_WAIT 状态的连接。
net.ipv4.tcp_tw_reuse
```

