# 指针与数组

### 初始化数组

```c
int arr[5] = {1, 2, 3, 4, 5};

// 编译器自动匹配数组大小和初始化列表中的项数
int arr[] = {1, 2, 3, 4, 5};

// 只能检索数组不能修改
const int arr[5] = {1, 2, 3, 4, 5};

// *p 修改不行，arr可以修改因为没有const限定
int arr[] = {1， 2}
const int *p = arr;

// 如果未初始化就是内存中原来的值，部分初始化剩下的就是0
int arr[3] = {1}

// 指定初始化器(C99)
int arr[6] = {[5] = 200};
int arr[6] = {1, 2, [4] = 3, 4} // 1, 2, 0, 0, 3, 4

// 吧const数据或非const数据的地址初始化为指向const的指针或为其赋值是合法的
// 吧const数据的指针赋值给非const数据的指针是非法的
int arr[2] = {1, 2};
const int arr1[2] = {1, 2};
const int *p = arr; // 有效
const int *p1 = arr1; // 有效
int *p2 = arr; // 有效
int *p3 = arr1; // 无效

const int * const pc; // 不能修改指针也不能修改值
```

* C不允许吧数组作为一个单元赋值给另外一个数组
* 除了初始化以外也不允许使用花括号列表的形式赋值

------

### 指针和数组的区别

```c
// a = &a[0]
int a[];
int *p;
```

* 数组名是该元素的首地址
* 指针的值是它所指向对象的地址

------

### 指针求差

```c
int a[] = {1, 2, 3, 4, 5}
int *p = a;
int *p1 = &a[4];

// 表示相隔4个int， a + sizeof(int) * 4 = p1;
p1 - p = 4
```

------

### 解引用未初始化的指针

```c
int *a;
*a = 12;
```

* 未进行初始化，指针的值是一个随机值。
* 可能擦写数据或者程序崩溃。

------

### 指针和多维数组

```c
int a[2][4] = { {1, 2, 3, 4}, {10, 9, 8, 7} };

// 修改的是a这个对象，它指向的对象占用4个字节
**(a + 1);  // 10

// 指向的是a[0]这个对象，它指向的对象占用1个字节
*(*a + 1); // 2
*(*(a + 1) + 2) // 8
```

------

### 指向多维数组的指针

```c
int (*a)[4]; // a指向内含两个int的数组，也叫数组指针

// 这样是允许的，因为指向的是a[0]这个对象
int *p = &a[0];

// 区别指向多维数组的指针
int *a[4] // []优先级比*高，a是内含4个指针类型的元素，也叫指针数组
```

------

### 指针的兼容性

```c
int n = 5;
double x;
int *p = &n;
double *p1 = &x;

x = n; // 隐式转换
p = p1; // 编译时报错
```

------

### 复合字面量

```c
(int []) {1, 2, 3}
(int [2]) {1, 2}

demo((int [2]) {1, 2}, (int []) {1, 2, 3});
```

------

### 函数指针

```c
int (*function) (void *, void*)
```

------

### 二级指针删除单向链表

```c
void remove_if(node ** head, remove_fn rm)
{
    for (node** curr = head; *curr; ) {
        node * entry = *curr;
        if (rm(entry)) {
            *curr = entry->next;
            free(entry);
        }
        else
            curr = &entry->next;
    }
}
```

